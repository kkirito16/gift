#include glut.h
#include cmath
#includeSOIL.h

#define PI 3.1415926
#define RESOLUTION 100  定义分辨率
GLuint caustic_texture;

float amplitude = 0.01;
float wavelength = 0.3;
float speed = -0.2;
float center[1][2] = { {0.0,0.0} };  修正center数组定义
float surface[(RESOLUTION + 1)  (RESOLUTION + 1)  3];
float normal[(RESOLUTION + 1)  (RESOLUTION + 1)  3];
bool wire_frame = false;  添加wire_frame变量
bool normals = false;  添加normals变量

float dot(float x, float y) {
	float cx = x - center[0][0];
	float cy = y - center[0][1];
	return sqrt(cx  cx + cy  cy);
}

float waveHeight(float x, float y, float time) {
	float frequency = 2  PI  wavelength;
	float phase = speed  frequency;
	float theta = dot(x, y);
	return amplitude  sin(theta  frequency + time  phase);
}

float dWavedx(float x, float y, float time) {
	float frequency = 2  PI  wavelength;
	float phase = speed  frequency;
	float theta = dot(x, y);
	float A = amplitude  x  frequency  theta;
	return A  cos(theta  frequency + time  phase);
}

float dWavedy(float x, float y, float time) {
	float frequency = 2  PI  wavelength;
	float phase = speed  frequency;
	float theta = dot(x, y);
	float A = amplitude  y  frequency  theta;
	return A  cos(theta  frequency + time  phase);
}

struct Vector3
{
	float x;
	float y;
	float z;
};

Vector3 waveNormal(float x, float y, float time) {
	float dx = dWavedx(x, y, time);
	float dy = dWavedy(x, y, time);
	Vector3 n;
	n.x = -dx;
	n.y = 1.0;
	n.z = -dy;
	float l = sqrt(n.x  n.x + n.y  n.y + n.z  n.z);
	if (l != 0) {
		n.x = l;
		n.y = l;
		n.z = l;
	}
	else {
		n.x = 0;
		n.y = 1;
		n.z = 0;
	}
	return n;
}

int LoadGLTextures() {
	caustic_texture = SOIL_load_OGL_texture(
		.reflection.jpg,
		SOIL_LOAD_AUTO,
		SOIL_CREATE_NEW_ID,
		SOIL_FLAG_INVERT_Y
	);
	if (caustic_texture == 0)
		return false;
	glBindTexture(GL_TEXTURE_2D, caustic_texture);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glEnable(GL_TEXTURE_GEN_S);
	glEnable(GL_TEXTURE_GEN_T);
	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
	glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
	return true;
}

int InitGL() {
	if (!LoadGLTextures())
		return false;

	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	glClearDepth(1.0f);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
	return true;
	GLfloat LightAmbient[] = { 0.9f,0.9f,0.9f,1.0f };
	GLfloat LightDiffuse[] = { 0.9f,0.9f,0.9f,1.0f };
	GLfloat LightPosition[] = { 1.0f,1.0f,-0.5f,0.0f };
	glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);
	glLightfv(GL_LIGHT1, GL_POSITION, LightPosition);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHTING);
	glColorMaterial(GL_FRONT, GL_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
}

void changeSize(int w, int h)
{
	if (h == 0) h = 1;
	float ratio = 1.0  w  h;
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glViewport(0, 0, w, h);
	gluPerspective(20, ratio, 0.1, 15);
	glMatrixMode(GL_MODELVIEW);
	glutPostRedisplay();
}

void Keyboard(unsigned char key, int x, int y) {
	switch (key) {
	case 'q'
	case 27
		exit(0);
		break;
	case 'l'
		wire_frame = !wire_frame;
		break;
	case 'n'
		normals = !normals;
		break;
	}
}

bool left_click = false;
bool right_click = false;
int xold, yold;

void Mouse(int button, int state, int x, int y) {
	if (GLUT_LEFT_BUTTON == button)
		left_click = state;
	if (GLUT_RIGHT_BUTTON == button)
		right_click = state;
	xold = x;
	yold = y;
}
void mouseMotion(int x, int y) {
	if (GLUT_DOWN == left_click) {
		rotate_y = rotate_y + (y - yold)  5.0;
		rotate_x = rotate_x + (x - xold)  5.0;
	}
	if (rotate_y   90)
		rotate_y  = 90;
	if (rotate_y   -90)
		rotate_y  = -90;
	glutPostRedisplay();
	if (GLUT_DOWN  == right_click)
	{
		translate_z  = translate_z  + (yold  - y)  50.;
		if (translate_z   0.5)
			translate_z  = 0.5;
		if (translate_z   10)
			translate_z  = 10;
		glutPostRedisplay();
		xold  = x;
		yold  = y;
	}
}



void renderScene() {
	glClear(GL_COLOR_BUFFER_BIT  GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	gluLookAt(0.0, 1.0, -4.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

	 生成水面
	float time = glutGet(GLUT_ELAPSED_TIME)  1000.0;
	int index = 0;
	for (int i = 0; i  RESOLUTION; i++) {
		for (int j = 0; j = RESOLUTION; j++) {
			float x = (float)j  RESOLUTION - 0.5;
			float z = (float)i  RESOLUTION - 0.5;
			surface[index] = x;
			surface[index + 1] = waveHeight(x, z, time);
			surface[index + 2] = z;
			normal[index] = waveNormal(x, z, time).x;
			normal[index + 1] = waveNormal(x, z, time).y;
			normal[index + 2] = waveNormal(x, z, time).z;
			index += 3;
		}
	}

	 绘制水面
	if (wire_frame) {
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	}
	else {
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}

	glBegin(GL_TRIANGLE_STRIP);
	for (int i = 0; i  RESOLUTION; i++) {
		for (int j = 0; j = RESOLUTION; j++) {
			int index1 = i  (RESOLUTION + 1)  3 + j  3;
			int index2 = (i + 1)  (RESOLUTION + 1)  3 + j  3;
			if (normals) {
				glNormal3f(normal[index1], normal[index1 + 1], normal[index1 + 2]);
			}
			glVertex3f(surface[index1], surface[index1 + 1], surface[index1 + 2]);
			if (normals) {
				glNormal3f(normal[index2], normal[index2 + 1], normal[index2 + 2]);
			}
			glVertex3f(surface[index2], surface[index2 + 1], surface[index2 + 2]);
		}
	}
	glEnd();
	glEnable(GL_TEXTURE_2D);
	glutSwapBuffers();
}
float dot(int i, float x, float y) {
	float xc  = x  - centers[i][0];
	float yc  = y  - centers[i][1];
	return sqrt(xc   xc  + yc   yc);
}
float wave(int i, float x, float y, float time) {
	float frequency  = 2  PI   wavelength[i];
	float phase  = speed[i]  frequency;
	float theta  = dot(i, x, y);
	return amplitude[i]  sin(theta   frequency  + time   phase);
}
float waveHeight(float x, float y, float time) {
	float height  = 0.0;
	for (int i  = 0; i   numWaves; i++)
		height  += wave(i, x, y, time);
	return height;
}
float dWavedx(int i, float x, float y, float time) {
	float frequency  = 2  PI   wavelength[i];
	float phase  = speed[i]  frequency;
	float theta  = dot(i, x, y);
	float A  = amplitude[i]  x   frequency   theta;
	return A  cos(theta   frequency  + time   phase);
}
float dWavedy(int i, float x, float y, float time) {
	float frequency  = 2  PI   wavelength[i];
	float phase  = speed[i]  frequency;
	float theta  = dot(i, x, y);
	float A  = amplitude[i]  y   frequency   theta;
	return A  cos(theta   frequency  + time   phase);
}
Vector3 waveNormal(float x, float y, float time) {
	float dx  = 0.0;
	float dy  = 0.0;
	for (int i  = 0; i   numWaves; i++) {
		dx  += dWavedx(i, x, y, time);
		dy  += dWavedy(i, x, y, time);
	}
	Vector3 n;
	n.x  = -dx;
	n.y  = 1.0;
	n.z  = -dy;
	float l  = sqrt(n.x   n.x  + n.y   n.y  + n.z   n.z);
	if (1 != 0) {
		n.x  = n.x   1;
		n.y  = n.y   1;
		n.z  = n.z   1;
	}
	else {
		n.x  = 0;
		n.y  = 1;
		n.z  = 0;
	}
	return n;
}
int main(int argc, char argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGB  GLUT_DOUBLE  GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutCreateWindow(Water);
	 OpenGL settings
	InitGL();
	 register callbacks
	glutDisplayFunc(renderScene);
	glutReshapeFunc(changeSize);
	glutKeyboardFunc(Keyboard);
	glutMouseFunc(Mouse);
	 enter GLUT event processing cycle
	glutMainLoop();
	return 0;
}